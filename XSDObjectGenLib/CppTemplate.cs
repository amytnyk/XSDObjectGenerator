using System;
using System.Xml;
using System.Xml.Schema;
using System.IO;
using System.Collections;
using System.Collections.Generic;

namespace XSDObjectGenLib
{
    /// <summary>
    /// LanguageBase implementation for Cpp.
    /// </summary>
    internal class CppTemplate : LanguageBase
    {
        static string sElementAnyTemplate =
@"		[XmlAnyElement({6})]
		public System.Xml.XmlElement {5};";

        static string sElementAnyMaxOccursTemplate =
@"		[XmlAnyElement({6})]
		public System.Xml.XmlElement[] {5};";
	
        static string sAttributeAnyTemplate =
@"		[XmlAnyAttribute()]
		public System.Xml.XmlAttribute[] {5};";

     
        static string sClassEnumerabilityTemplate = "";

        private Hashtable keywordsTable;

        String[] keywords =
                {   "abstract","as","base","bool","break","byte","case","catch","char",
                    "checked","class","const","continue","DateTime","decimal","Declarations","default","delegate",
                    "do","double","else","enum","event","explicit","extern","false",
                    "finally","fixed","float","for","foreach","get","goto","if","implicit",
                    "in","int","interface","internal","is","lock","long","namespace",
                    "new","null","object","operator","out","override","params",
                    "private","protected","public","readonly","ref","return","sbyte",
                    "sealed","set","short","sizeof","stackalloc","static","string","struct",
                    "switch","this","throw","Time","true","try","typeof","uint","ulong",
                    "unchecked","unsafe","ushort","using","value","virtual","void","while"};


        public CppTemplate()
        {
            keywordsTable = new Hashtable(keywords.Length);
            for (int i = 0; i < keywords.Length; i++)
                keywordsTable.Add(keywords[i].ToLower(), "");
        }
		
        protected override string AttributeAssignmentOperator { get { return "="; } }
        protected override string HideInheritedMethodKeyword { get { return "new "; } }
        protected override string PartialKeyword { get { return "partial "; } }

        public override void NamespaceHeaderCode(GeneratorStream generator, String ns, String schemaFile,
            Hashtable forwardDeclarations, string targetNamespace, Hashtable enumerations, bool depthFirstTraversalHooks,
            ArrayList importedReferences)
        {
            schemaTargetNamespace = targetNamespace;

            /*outStream.WriteLine("#pragma once");
            outStream.WriteLine();
            outStream.WriteLine("// Copyright 2008, Microsoft Corporation and 2019 Alex Mytnyk");
            outStream.WriteLine("// Sample Code - Use restricted to terms of use defined in the accompanying license agreement (EULA.doc)");
            outStream.WriteLine();
            outStream.WriteLine("//--------------------------------------------------------------");
            outStream.WriteLine("// Autogenerated by XSDObjectGen version {0}",
                this.GetType().Assembly.GetName(false).Version);
            outStream.WriteLine("// Schema file: {0}", schemaFile);
            outStream.WriteLine("// Creation Date: {0}", DateTime.Now.ToString());
            outStream.WriteLine("//--------------------------------------------------------------");
            outStream.WriteLine();*/
            //outStream.WriteLine("using System;");
            //outStream.WriteLine("using System.Xml.Serialization;");
            //outStream.WriteLine("using System.Collections;");
            //outStream.WriteLine("using System.Collections.Generic;");
            //outStream.WriteLine("using System.Xml.Schema;");
            //outStream.WriteLine("using System.ComponentModel;");
            /*outStream.WriteLine("#include <iostream>");
            outStream.WriteLine("#include <string>");
            outStream.WriteLine("#include <ctime>");

            outStream.WriteLine();
            outStream.WriteLine("namespace {0}", ns);
            outStream.WriteLine("{");
            outStream.WriteLine();
            outStream.WriteLine("\tstruct Declarations");
            outStream.WriteLine("\t{");
            outStream.WriteLine(string.Format("\t\tconst std::string SchemaVersion = \"{0}\";", targetNamespace));
            outStream.WriteLine("\t};");
            outStream.WriteLine("\t//BEGIN_CPP2SERIALIZE");*/

            if (depthFirstTraversalHooks)
            {
                //outStream.WriteLine("\tpublic delegate void DepthFirstTraversalDelegate(object instance, object parent, object context);");
                //outStream.WriteLine();
            }
            
            // Add enumerations
            foreach (string key in enumerations.Keys)
            {
                //outStream.WriteLine("\t[Serializable]");

                string code = "";
                code += string.Format("\tenum {0}", key) + "\n";
                code += "{\n";

               ArrayList enumValues = (ArrayList)enumerations[key];
                for (int i = 0; i < enumValues.Count; i++)
                {
                    string[] enumValue = (string[])enumValues[i];
                    if (i == (enumValues.Count - 1))
                    {
                        if (key.StartsWith("OLI_LU_"))
                            code += string.Format("\t\t{1} = {0}", enumValue[0], CheckForKeywords(enumValue[1])) + "\n";
                        else
                            code += string.Format("\t\t{1}", enumValue[0], CheckForKeywords(enumValue[1])) + "\n";
                    }
                    else
                    {
                        if (key.StartsWith("OLI_LU_"))
                            code += string.Format("\t\t{1} = {0},", enumValue[0], CheckForKeywords(enumValue[1])) + "\n";
                        else
                            code += string.Format("\t\t{1},", enumValue[0], CheckForKeywords(enumValue[1])) + "\n";
                    }
                }

                code += "\t};";

                generator.put_Enum(code);
            }

            
        }

        public override void ClassHeaderCode(GeneratorStream generator, string dotnetClassName, string elementName,
            string complexTypeBaseClass, bool baseIsAbstract, bool isSchemaType, bool isAbstract, bool isLocalComplexType, Hashtable enumerableClasses,
            string ns, XmlSchemaForm elementFormDefault, string annotation, bool isElementNullable, ArrayList xmlIncludedClasses,
            bool globalElementAndSchemaTypeHaveSameName)
        {
            

            string nameSpace = "";
            if (isSchemaType)
            {
                if (elementFormDefault == XmlSchemaForm.Qualified || elementFormDefault == XmlSchemaForm.Unqualified)
                {
                    nameSpace = CalculateNamespace(schemaTargetNamespace, ns, false);
                }
                if (globalElementAndSchemaTypeHaveSameName)
                {
                    //outStream.WriteLine("\t[XmlRoot(ElementName=\"{0}\"{1},IsNullable={2}),Serializable]",
                    //    elementName, nameSpace, isElementNullable.ToString().ToLower());
                    //outStream.WriteLine("\t[XmlType(TypeName=\"{0}\"{1})]",
                    //    dotnetClassName, nameSpace);
                }
                else
                {
                    //outStream.WriteLine("\t[XmlType(TypeName=\"{0}\"{1}),Serializable]", dotnetClassName, nameSpace);
                }
            }
            else if (isLocalComplexType)
            {
                if (elementFormDefault == XmlSchemaForm.Qualified || elementFormDefault == XmlSchemaForm.Unqualified)
                {
                    nameSpace = CalculateNamespace(schemaTargetNamespace, ns, false);
                }
                //outStream.WriteLine("\t[XmlType(TypeName=\"{0}\"{1}),Serializable]",
                //    dotnetClassName, nameSpace);
            }
            else
            {
                // possible root node element -- so put namespace on the element if targetNamesapce has been set
                nameSpace = CalculateNamespace(schemaTargetNamespace, ns, false);
                //outStream.WriteLine("\t//MAIN_CLASS");
                //outStream.WriteLine("\t[XmlRoot(ElementName=\"{0}\"{1},IsNullable={2}),Serializable]",
                //    elementName, nameSpace, isElementNullable.ToString().ToLower());
            }

            // Add necessary XmlInludes for abstract derived types used in the class
            foreach (string xmlIncludeClass in xmlIncludedClasses)
            {
                //outStream.WriteLine("\t[XmlInclude(typeof({0}))]", CheckForKeywords(xmlIncludeClass));
            }

            string className = CheckForKeywords(dotnetClassName);

            // outStream.WriteLine("\t//CLASS");

            //outStream.Write("\t{1}{2}struct {0}", className, isAbstract ? "abstract " : "", partialClasses ? PartialKeyword : "");

            // setup inheritance for <xsd:extension base="class"> 
            string inheritance = "";
            if (complexTypeBaseClass != null && complexTypeBaseClass != "")
                inheritance = string.Format(" : {0}", CheckForKeywords(complexTypeBaseClass));
			Console.WriteLine(elementName + " " + className);
            generator.begin_class(elementName, isAbstract ? "abstract " : "", inheritance);
            //outStream.WriteLine();
            //outStream.WriteLine("\t{");

            // setup enumerability over a contained collection
            if (enumerableClasses.ContainsKey(dotnetClassName))
            {
                ArrayList values = (ArrayList)enumerableClasses[dotnetClassName];
                string collectionName = (string)values[0];
                collectionName = ReplaceInvalidChars(collectionName);
                //outStream.WriteLine(ClassEnumerabilityTemplate, collectionName,
                //    ConvertSystemDatatype((string)values[1]), collectionSuffix, hiddenMemberPrefix);
            }
        }

        public override void ClassTrailerCode(GeneratorStream generator, string dotnetClassName, ArrayList ctorList,
            bool defaultInitialization, bool depthFirstTraversalHooks, bool makeSchemaCompliant, string complexTypeBaseClass, bool baseClassIsMixed, bool mixed, string mixedXsdType)
        {
            // For mixed content (an element that has children and also text), add a special text field.
            // Base class cannot be mixed, otherwise XmlSerializer error will occur.  Can only have 1 XmlText().
            if (mixed && !baseClassIsMixed)
            {
                

                string clrType;
                if (mixedXsdType.StartsWith("System."))
                {
                    clrType = mixedXsdType;
                    mixedXsdType = XsdTypeMapping(mixedXsdType);
                }
                else
                    clrType = FrameworkTypeMapping(mixedXsdType);

                /*if (clrType == "System.DateTime")
                    outStream.WriteLine(MixedDateTimeTemplate, clrType, mixedXsdType, hiddenMemberPrefix, mixedElementFieldName);
                else if (IsValueType(clrType))
                    outStream.WriteLine(MixedValueTypeTemplate, ConvertSystemDatatype(clrType), clrType, hiddenMemberPrefix, mixedElementFieldName);
                else
                    outStream.WriteLine(MixedObjectTemplate, "string", "string", hiddenMemberPrefix, mixedElementFieldName);
                */        
            }

            bool inherits = (complexTypeBaseClass != null && complexTypeBaseClass != "");

            // Add a class constructor

            //outStream.WriteLine("\t\t//*********************** Constructor ***********************");

            generator.put_Constructor(CheckForKeywords(dotnetClassName), inherits ? " : super()" : "");
            //outStream.WriteLine("\t\t{0}(){1}", CheckForKeywords(dotnetClassName), inherits ? " : super()" : "");
            //outStream.WriteLine("\t\t{");

            // Default any DateTime fields to a value.
            /*for (int i = 0; i < ctorList.Count; i++)
            {
                ClassConstructor ctor = (ClassConstructor)ctorList[i];
                // make sure the datetime fields are initialized to Now if a constructor default value is not set
                if (ctor.datatype == CtorDatatypeContext.DateTime && (!defaultInitialization || (defaultInitialization && !ctor.required)))
                {
                    //outStream.WriteLine("\t\t\t{1}{0} = System.DateTime.Now;", ReplaceInvalidChars(ctor.fieldName), hiddenMemberPrefix);
                }
            }*/

            //outStream.WriteLine("\t\t}"); // End of constructor

            // If some fields in the class have defaults or fixed values, add a constructor.
            // Also force creation of required attributes and elmenets, so the schema is always valid.
            /*if (defaultInitialization)
            {
                for (int i = 0; i < ctorList.Count; i++)
                {
                    ClassConstructor ctor = (ClassConstructor)ctorList[i];
                    if (!ctor.required) continue;

                    if (ctor.datatype == CtorDatatypeContext.PropertyCollection ||
                        ctor.datatype == CtorDatatypeContext.PropertyCollectionString ||
                        ctor.datatype == CtorDatatypeContext.PropertyCollectionComplexType ||
                        ctor.datatype == CtorDatatypeContext.PropertyCollectionAbstractComplexType)
                    {
                    }
                    else if (ctor.datatype == CtorDatatypeContext.Property)   // class instance field -- so build code to force the constructor to fire and create an instance
                    {
                        //	outStream.WriteLine("\t\t\t{0} obj{1} = {2};", CheckForKeywords(ctor.fieldName), i, CheckForKeywords(ctor.defaultValue));
                    }
                    else if (ctor.datatype == CtorDatatypeContext.DateTime) // standard value type with no default value
                    {
                        //outStream.WriteLine("\t\t\t{0} = System.DateTime.Now;", ReplaceInvalidChars(ctor.fieldName));
                    }
                    else if (ctor.datatype == CtorDatatypeContext.ValueType) // standard value type with no default value
                    {
                        //outStream.WriteLine("\t\t\t{1}{0}Specified = true;", ReplaceInvalidChars(ctor.fieldName), hiddenMemberPrefix);
                    }
                    else if (ctor.datatype == CtorDatatypeContext.ValueTypeDefault) //  valuetypes field with a default value
                    {
                        //outStream.WriteLine("\t\t\t{0} = {1};", CheckForKeywords(ctor.fieldName), ctor.defaultValue);
                    }
                    else if (ctor.datatype == CtorDatatypeContext.String)
                    {
                        //if (ctor.defaultValue == "")
                            //outStream.WriteLine("\t\t\t{0} = string.Empty;", CheckForKeywords(ctor.fieldName), ctor.defaultValue);
                        //else
                            //outStream.WriteLine("\t\t\t{0} = \"{1}\";", CheckForKeywords(ctor.fieldName), ctor.defaultValue);
                    }
                }
            }*/


            // Add MakeSchemaCompliant code for required child classes
            if (makeSchemaCompliant)
            {
                /*outStream.WriteLine();
                //outStream.WriteLine("\t\t//*********************** MakeSchemaCompliant ***********************");
                outStream.WriteLine("\t\t{0}public void MakeSchemaCompliant()", (inherits) ? HideInheritedMethodKeyword : "");
                outStream.WriteLine("\t\t{");
                if (inherits) outStream.WriteLine("\t\t\tbase.MakeSchemaCompliant();");

                for (int i = 0; i < ctorList.Count; i++)
                {
                    ClassConstructor ctor = (ClassConstructor)ctorList[i];
                    if (!ctor.required) continue;

                    // removed makeschemacompliant Add calls due to generic list
                    if (ctor.datatype == CtorDatatypeContext.PropertyCollection)
                    {
                        //outStream.WriteLine("\t\t\tif ({0}{1}.Count == 0) {0}{1}.Add();", ReplaceInvalidChars(ctor.defaultValue),
                        //    collectionSuffix);
                    }
                    else if (ctor.datatype == CtorDatatypeContext.PropertyCollectionString)
                    {
                        //outStream.WriteLine("\t\t\tif ({0}{1}.Count == 0) {0}{1}.Add(\"\");", ReplaceInvalidChars(ctor.defaultValue),
                        //    collectionSuffix);
                    }
                    else if (ctor.datatype == CtorDatatypeContext.PropertyCollectionComplexType)
                    {
                        outStream.WriteLine("\t\t\tforeach ({0} _c in {1}) _c.MakeSchemaCompliant();", CheckForKeywords(ctor.fieldName),
                            ReplaceInvalidChars(ctor.defaultValue));
                    }
                    else if (ctor.datatype == CtorDatatypeContext.PropertyCollectionAbstractComplexType)
                    {
                        // note: there is no .Add() method to call for the "abstract" case -- since the code generator has 
                        //  no idea what type will be added into the collection.
                        outStream.WriteLine("\t\t\tforeach ({0} _c in {1}) _c.MakeSchemaCompliant();", CheckForKeywords(ctor.fieldName),
                            ReplaceInvalidChars(ctor.defaultValue));
                    }
                    else if (ctor.datatype == CtorDatatypeContext.Property)   // class instance field -- so build code to force the constructor to fire and create an instance
                    {
                        outStream.WriteLine("\t\t\t{0}.MakeSchemaCompliant();", CheckForKeywords(ctor.defaultValue));
                    }
                }

                outStream.WriteLine("\t\t}");*/
            }

            // Add DepthFirstTraversal hooks
            if (depthFirstTraversalHooks)
            {
                /*outStream.WriteLine();
                //outStream.WriteLine("\t\t//*********************** DepthFirstTraversal Event ***********************");
                outStream.WriteLine("\t\t{0}public static event DepthFirstTraversalDelegate DepthFirstTraversalEvent;", (inherits) ? HideInheritedMethodKeyword : "");
                outStream.WriteLine("\t\t{0}public void DepthFirstTraversal(object parent, object context)", (inherits) ? HideInheritedMethodKeyword : "");
                outStream.WriteLine("\t\t{");
                outStream.WriteLine("\t\t\tif (DepthFirstTraversalEvent != null) DepthFirstTraversalEvent(this, parent, context);");
                if (inherits) outStream.WriteLine("\t\t\tbase.DepthFirstTraversal(parent, context);");

                for (int i = 0; i < ctorList.Count; i++)
                {
                    ClassConstructor ctor = (ClassConstructor)ctorList[i];
                    if (ctor.datatype == CtorDatatypeContext.PropertyCollectionComplexType || ctor.datatype == CtorDatatypeContext.PropertyCollectionAbstractComplexType)
                    {
                        outStream.WriteLine("\t\t\tif ({0}{1} != null) foreach ({3} _d in {4}{5}) _d.DepthFirstTraversal(this, context);", hiddenMemberPrefix, ReplaceInvalidChars(ctor.defaultValue), collectionSuffix,
                            CheckForKeywords(ctor.fieldName), hiddenMemberPrefix, ReplaceInvalidChars(ctor.defaultValue));
                    }
                    else if (ctor.datatype == CtorDatatypeContext.Property)   // class instance field -- so build code to force the constructor to fire and create an instance
                    {
                        outStream.WriteLine("\t\t\tif ({0}{1} != null) {0}{1}.DepthFirstTraversal(this, context);", hiddenMemberPrefix, ReplaceInvalidChars(ctor.defaultValue));
                    }
                }

                outStream.WriteLine("\t\t}");*/
            }

            generator.end_class(); //End of class
        }

        public override void NamespaceTrailerCode(GeneratorStream generator, string ns)
        {
            //outStream.WriteLine("}");
            //outStream.WriteLine();
            //outStream.WriteLine("#pragma warning restore 1591 ");
        }

        public override string ConvertSystemDatatype(string systemType)
        {
            switch (systemType)
            {
                case "System.String":
                    return "std::string";
                case "System.SByte":
                    return "sbyte";
                case "System.Byte":
                    return "char";
                case "System.Int16":
                    return "short int";
                case "System.UInt16":
                    return "unsigned short int";
                case "System.Int32":
                    return "int";
                case "System.UInt32":
                    return "unsigned int";
                case "System.Int64":
                    return "long int";
                case "System.UInt64":
                    return "unsigned long int";
                case "System.Single":
                    return "float";
                case "System.Double":
                    return "double";
                case "System.Boolean":
                    return "bool";
                case "System.Decimal":
                    return "int";
                case "System.Char":
                    return "char";
                case "System.Object":
                    return "object";
                case "System.Byte[]":
                    return "byte[]";
                case "System.DateTime":
                    return "DateTime";
                case "System.Xml.XmlQualifiedName":
                    return "System.Xml.XmlQualifiedName";
                case "System.Xml.XmlElement":
                    return "System.Xml.XmlElement";
                case "System.Xml.XmlAttribute[]":
                    return "System.Xml.XmlAttribute[]";
                default:
                    // other value types, change type to string
                    if (systemType.StartsWith("System."))
                        return "string";
                    else // custom enum types
                        return CheckForKeywords(systemType);
            }
        }

        // todo: put this into LanguageTemplate as only one line of code differs from VB
        public override string CheckForKeywords(String keyword)
        {
            string modifiedKeyword = keyword;

            // if a namespace prefixes the word, check the right half of the qualified value
            string[] cct = keyword.Split('.');
            if (cct != null && cct.Length >= 2 && !keyword.StartsWith("System."))
            {
                modifiedKeyword = cct[cct.Length - 1];
            }

            modifiedKeyword = ReplaceInvalidChars(modifiedKeyword);
            if (keywordsTable.ContainsKey(modifiedKeyword.ToLower()))
                modifiedKeyword = "@" + modifiedKeyword;


            if (cct != null && cct.Length >= 2 && !modifiedKeyword.StartsWith("System."))
            {
                string ret = "";
                for (int i = 0; i < cct.Length - 1; i++)
                    ret = ret + cct[i] + "::";
                ret = ret + modifiedKeyword;
                modifiedKeyword = ret;
            }

            return modifiedKeyword;
        }
    }
}
